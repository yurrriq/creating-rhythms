-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell port of the code from the book <a>Creating Rhythms</a> by
--   Stefan Hollos and J. Richard Hollos.
@package CreatingRhythms
@version 0.0.28.1


-- | Binary rhythm definitions, including conversion to ABC notation.
module Data.Rhythm.BDF

-- | A binary rhythm definition consists of a tempo, a note count
--   &lt;math&gt;, a rhythm count &lt;math&gt;, and a list of &lt;math&gt;
--   binary rhythms consisting of &lt;math&gt; notes.
data BinaryRhythmDefinition
BinaryRhythmDefinition :: !Int -> !Int -> !Int -> ![BinaryRhythm] -> BinaryRhythmDefinition

-- | beats per minute
[tempo] :: BinaryRhythmDefinition -> !Int

-- | number of notes in each rhythm
[noteCount] :: BinaryRhythmDefinition -> !Int

-- | number of rhythms
[rhythmCount] :: BinaryRhythmDefinition -> !Int

-- | a list of binary rhythms
[rhythms] :: BinaryRhythmDefinition -> ![BinaryRhythm]

-- | A binary rhythm consists of a MIDI instrument number and a list of
--   binary words where a <tt>1</tt> represents an onset.
data BinaryRhythm
BinaryRhythm :: !Int -> ![Finite 2] -> BinaryRhythm

-- | MIDI instrument number
[instrumentNumber] :: BinaryRhythm -> !Int

-- | a list of zeros and ones
[notes] :: BinaryRhythm -> ![Finite 2]

-- | Parse a binary rhythm definition.
binaryRhythmDefinition :: Parser BinaryRhythmDefinition

-- | Given a title and a number of repeats, represent a binary rhythm
--   definition using ABC notation.
toAbcString :: String -> Int -> BinaryRhythmDefinition -> String
instance GHC.Classes.Eq Data.Rhythm.BDF.BinaryRhythm
instance GHC.Classes.Eq Data.Rhythm.BDF.BinaryRhythmDefinition
instance GHC.Show.Show Data.Rhythm.BDF.BinaryRhythmDefinition
instance GHC.Show.Show Data.Rhythm.BDF.BinaryRhythm


-- | Binary <a>necklaces</a> via the set of Lyndon words generated by an
--   inverse <a>Burrows-Wheeler transform</a>. Modified from <a>Rosetta
--   Code</a>.
module Data.Rhythm.Binary.BurrowsWheeler

-- | All binary necklaces of a given length.
--   
--   <pre>
--   &gt;&gt;&gt; necklaces 4
--   [[1,1,1,1],[1,1,1,0],[1,1,0,0],[1,0,1,0],[1,0,0,0],[0,0,0,0]]
--   </pre>
necklaces :: Int -> [[Int]]

-- | The set of Lyndon words generated by an inverse Burrows-Wheeler
--   transform.
--   
--   <pre>
--   &gt;&gt;&gt; lyndonWords [0,1] 4
--   [[0],[0,0,0,1],[0,0,1,1],[0,1],[0,1,1,1],[1]]
--   </pre>
lyndonWords :: Ord a => [a] -> Int -> [[a]]

-- | Represent a permutation in a cycle notation.
--   
--   <pre>
--   &gt;&gt;&gt; cycleForm [1,5,4,3,2,0]
--   [[1,5,0],[4,2],[3]]
--   </pre>
cycleForm :: [Int] -> [[Int]]


-- | Binary <a>necklaces</a>, internally encoded as numbers.
--   
--   <h1>References</h1>
--   
--   <ul>
--   <li>Frank Ruskey, Carla Savage, Terry Min Yih Wang, Generating
--   necklaces, Journal of Algorithms, Volume 13, Issue 3, 1992, Pages
--   414-430, ISSN 0196-6774,
--   <a>https://doi.org/10.1016/0196-6774(92)90047-G</a>.</li>
--   </ul>
module Data.Rhythm.Binary.RuskeySavageWang

-- | All binary necklaces of a given length.
--   
--   <pre>
--   &gt;&gt;&gt; necklaces 4
--   [[1,1,1,1],[1,1,1,0],[1,1,0,0],[1,0,1,0],[1,0,0,0],[0,0,0,0]]
--   </pre>
necklaces :: Int -> [[Int]]

-- | All binary necklaces of a given length, encoded as numbers.
--   
--   &lt;math&gt;
--   
--   Generate the tree of binary necklaces of length &lt;math&gt;, starting
--   with &lt;math&gt; as root, where children of &lt;math&gt; are the
--   necklaces of the form &lt;math&gt; for &lt;math&gt;.
--   
--   <pre>
--   &gt;&gt;&gt; flatten (necklaces' 4)
--   [0,1,3,7,15,5]
--   </pre>
necklaces' :: (Integral a, Bits a) => Int -> Tree a

-- | Convert a list of nodes to binary necklaces of a given length.
--   
--   <pre>
--   &gt;&gt;&gt; nodesToNecklaces 4 [3,5]
--   [[1,1,0,0],[1,0,1,0]]
--   </pre>
nodesToNecklaces :: Int -> [Integer] -> [[Int]]


-- | De Bruijn sequences, and conversion between binary strings and lists
--   of intervals.
module Data.Rhythm.Binary

-- | Convert a binary string to a list of intervals.
--   
--   <pre>
--   &gt;&gt;&gt; binaryToIntervals "1010010001001000"
--   [2,3,4,3,4]
--   </pre>
binaryToIntervals :: String -> [Int]

-- | Generate the largest de Bruijn sequence of a given order.
--   
--   Based on <a>http://debruijnsequence.org/db/greedy</a>.
--   
--   <pre>
--   &gt;&gt;&gt; deBruijnSequence 4
--   [1,1,1,1,0,1,1,0,0,1,0,1,0,0,0,0]
--   </pre>
deBruijnSequence :: Int -> [Int]

-- | Convert a list of intervals to a binary string.
--   
--   <pre>
--   &gt;&gt;&gt; intervalsToBinary [2,3,4,3,4]
--   "1010010001001000"
--   </pre>
intervalsToBinary :: [Int] -> String

-- | All binary necklaces of a given length.
--   
--   <pre>
--   &gt;&gt;&gt; necklaces 4
--   [[1,1,1,1],[1,1,1,0],[1,1,0,0],[1,0,1,0],[1,0,0,0],[0,0,0,0]]
--   </pre>
necklaces :: Int -> [[Int]]

-- | All binary necklaces of a given length, encoded as numbers.
--   
--   &lt;math&gt;
--   
--   Generate the tree of binary necklaces of length &lt;math&gt;, starting
--   with &lt;math&gt; as root, where children of &lt;math&gt; are the
--   necklaces of the form &lt;math&gt; for &lt;math&gt;.
--   
--   <pre>
--   &gt;&gt;&gt; flatten (necklaces' 4)
--   [0,1,3,7,15,5]
--   </pre>
necklaces' :: (Integral a, Bits a) => Int -> Tree a
necklacesAllowed :: [Int] -> Int -> [[Int]]

-- | All binary necklaces with a given number of ones of a given length.
--   
--   <pre>
--   &gt;&gt;&gt; necklacesPopCount 3 6
--   [[1,1,1,0,0,0],[1,1,0,1,0,0],[1,0,1,1,0,0],[1,0,1,0,1,0]]
--   </pre>
necklacesPopCount :: Int -> Int -> [[Int]]


-- | Christoffel words.
module Data.Rhythm.Christoffel

-- | Generate the upper or lower Christoffel word for a given slope with a
--   given number of terms.
--   
--   <pre>
--   &gt;&gt;&gt; christoffelWord False 3 7 Nothing
--   [0,0,0,1,0,0,1,0,0,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; christoffelWord True 3 7 Nothing
--   [1,0,0,1,0,0,1,0,0,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; christoffelWord True 3 7 (Just 20)
--   [1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,0]
--   </pre>
christoffelWord :: Bool -> Integer -> Integer -> Maybe Int -> [Integer]


-- | <a>Combinatorial compositions</a>, i.e., <a>partitions</a> in which
--   order is significant.
module Data.Rhythm.Compositions

-- | All positive compositions of a given number.
--   
--   <pre>
--   &gt;&gt;&gt; compositions 4
--   [[4],[1,3],[2,2],[3,1],[1,1,2],[1,2,1],[2,1,1],[1,1,1,1]]
--   </pre>
compositions :: Integral a => a -> [Composition]

-- | All positive compositions with allowed parts.
--   
--   <pre>
--   &gt;&gt;&gt; compositionsAllowed [1,2] 4
--   [[2,2],[1,1,2],[1,2,1],[2,1,1],[1,1,1,1]]
--   </pre>
compositionsAllowed :: Integral a => [Int] -> a -> [Composition]

-- | Positive compositions of a given length.
--   
--   <pre>
--   &gt;&gt;&gt; compositionsLength 2 5
--   [[1,4],[2,3],[3,2],[4,1]]
--   </pre>
--   
--   The number of positive compositions of &lt;math&gt; into &lt;math&gt;
--   parts is given by the following formula.
--   
--   &lt;math&gt;
--   
--   <pre>
--   &gt;&gt;&gt; let _C k n = toInteger (length (compositionsLength k n))
--   
--   &gt;&gt;&gt; let fact n = product [1 .. n]
--   
--   &gt;&gt;&gt; _C 2 5 == fact (5 - 1) `div` (fact (2 - 1) * fact (5 - 2))
--   True
--   </pre>
compositionsLength :: Int -> Int -> [[Int]]

-- | Positive compositions of a given length with allowed parts.
--   
--   <pre>
--   &gt;&gt;&gt; compositionsLengthAllowed 2 [2,3] 5
--   [[2,3],[3,2]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter (all (`elem` [2,3])) (compositionsLength 2 5)
--   [[2,3],[3,2]]
--   </pre>
compositionsLengthAllowed :: Int -> [Int] -> Int -> [Composition]

-- | Generate a random positive composition of a given number.
--   
--   <pre>
--   &gt;&gt;&gt; sum &lt;$&gt; randomComposition 13
--   13
--   </pre>
randomComposition :: Int -> IO Composition

-- | Generate a random positive composition of a given length.
--   
--   <pre>
--   &gt;&gt;&gt; sum &lt;$&gt; randomCompositionLength 3 33
--   33
--   </pre>
randomCompositionLength :: Int -> Int -> IO Composition


-- | <a>Simple continued fractions</a> represented by nonempty lists of
--   terms.
--   
--   &lt;math&gt;
module Data.Rhythm.ContinuedFractions

-- | A <a>ContinuedFraction</a> is a <a>NonEmpty</a>, potentially infinite,
--   list of integer <a>terms</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ContinuedFraction (1 :| [2,3,4])
--   [1;2,3,4]
--   </pre>
newtype ContinuedFraction
ContinuedFraction :: NonEmpty Integer -> ContinuedFraction
[terms] :: ContinuedFraction -> NonEmpty Integer

-- | Evaluate a finite <a>ContinuedFraction</a>.
--   
--   <pre>
--   &gt;&gt;&gt; collapseFraction (ContinuedFraction (1 :| [2,3,4]))
--   43 % 30
--   </pre>
collapseFraction :: ContinuedFraction -> Rational

-- | Calculate the <a>ContinuedFraction</a> representation of the square
--   root of a given number.
--   
--   <pre>
--   &gt;&gt;&gt; continuedFractionSqrt 7
--   [2;1,1,1,4]
--   </pre>
continuedFractionSqrt :: Integral a => a -> ContinuedFraction
instance GHC.Classes.Ord Data.Rhythm.ContinuedFractions.ContinuedFraction
instance GHC.Classes.Eq Data.Rhythm.ContinuedFractions.ContinuedFraction
instance GHC.Show.Show Data.Rhythm.ContinuedFractions.ContinuedFraction


-- | Fold sequences.
module Data.Rhythm.FoldSequences

-- | Generate fold sequences from given number of terms, number of bits,
--   and function number &lt;math&gt;.
--   
--   <pre>
--   &gt;&gt;&gt; foldSequence 7 4 2
--   [0,1,1,0,0,0,1]
--   </pre>
foldSequence :: Int -> Int -> Int -> [Int]


-- | Generating random numbers using a Markov chain.
module Data.Rhythm.Markov
data TransitionMatrix
TransitionMatrix :: Int -> Vector (Vector Double) -> TransitionMatrix
[size] :: TransitionMatrix -> Int
[unTransitionMatrix] :: TransitionMatrix -> Vector (Vector Double)
transitionMatrix :: Parser (Vector (Vector Double))

-- | Given how many numbers to create, the initial state, and a transition
--   matrix, generate random numbers using a Markov chain.
markovGen :: MonadIO m => Int -> Int -> Vector (Vector Double) -> m (Vector Int)
instance GHC.Show.Show Data.Rhythm.Markov.TransitionMatrix
instance GHC.Classes.Eq Data.Rhythm.Markov.TransitionMatrix


-- | <a>Integer partitions</a>, i.e., representations of integers as a sum
--   of positive integers where the order of the summands is not
--   significant.
module Data.Rhythm.Partitions

-- | Partitions of a given number.
--   
--   <pre>
--   &gt;&gt;&gt; partitions 3
--   [Partition [1,1,1],Partition [2,1],Partition [3]]
--   </pre>
partitions :: Int -> [Partition]

-- | Partitions with allowed parts.
--   
--   <pre>
--   &gt;&gt;&gt; partitionsAllowed [1,2,3] 4
--   [Partition [1,1,1,1],Partition [2,1,1],Partition [2,2],Partition [3,1]]
--   </pre>
partitionsAllowed :: Foldable t => t Int -> Int -> [Partition]

-- | Partitions of a given length.
--   
--   <pre>
--   &gt;&gt;&gt; partitionsLength 3 7
--   [Partition [3,2,2],Partition [3,3,1],Partition [4,2,1],Partition [5,1,1]]
--   </pre>
partitionsLength :: Int -> Int -> [Partition]

-- | Partitions of a given length with allowed parts.
--   
--   <pre>
--   &gt;&gt;&gt; partitionsLengthAllowed 2 [1,2,3] 4
--   [Partition [2,2],Partition [3,1]]
--   </pre>
partitionsLengthAllowed :: Foldable t => Int -> t Int -> Int -> [Partition]


-- | Strictly lexicographically larger permutations of a given list of
--   numbers.
module Data.Rhythm.Permutations

-- | Strictly lexicographically larger permutations of a given list of
--   numbers.
--   
--   <pre>
--   &gt;&gt;&gt; permutations [1,2,3]
--   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
--   
--   &gt;&gt;&gt; permutations [3,1,2]
--   [[3,1,2],[3,2,1]]
--   </pre>
permutations :: Integral a => [a] -> [[a]]

module Data.Rhythm.Random

-- | Generate a vector of random numbers with specified correlation.
randomFinites :: forall x y m. (KnownNat x, KnownNat y, MonadIO m) => Finite x -> Finite x -> m (Vector (1 + y) (Finite x))
