-- |
-- Module      : Data.Rhythm.Binary.BurrowsWheeler
-- Copyright   : (c) Eric Bailey, 2025
--
-- License     : MIT
-- Maintainer  : eric@ericb.me
-- Stability   : experimental
-- Portability : POSIX
--
-- Binary [necklaces](http://combos.org/necklace) via the set of Lyndon words
-- generated by an inverse [Burrows-Wheeler
-- transform](https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform).
-- Modified from [Rosetta
-- Code](https://rosettacode.org/wiki/De_Bruijn_sequences#Permutation-based).
module Data.Rhythm.Binary.BurrowsWheeler
  ( necklaces,
    lyndonWords,
    cycleForm,
  )
where

import Data.Functor.Base (ListF (..))
import Data.Functor.Foldable (ana)
import Data.IntMap.Strict ((!))
import qualified Data.IntMap.Strict as IntMap
import Data.List (elemIndices, sortOn)
import Data.List.Extra (snoc)
import Data.Ord (Down (..))

-- | All binary necklaces of a given length.
--
-- >>> necklaces 4
-- [[1,1,1,1],[1,1,1,0],[1,1,0,0],[1,0,1,0],[1,0,0,0],[0,0,0,0]]
necklaces :: Int -> [[Int]]
necklaces n =
  sortOn Down $
    map (reverse . take n . cycle) $
      lyndonWords [0, 1] n

-- | The set of Lyndon words generated by an inverse Burrows-Wheeler transform.
--
-- >>> lyndonWords [0,1] 4
-- [[0],[0,0,0,1],[0,0,1,1],[0,1],[0,1,1,1],[1]]
lyndonWords :: (Ord a) => [a] -> Int -> [[a]]
lyndonWords s n = map (ref !!) <$> cycleForm perm
  where
    ref = take (length s ^ n) (cycle s)
    perm = s >>= (`elemIndices` ref)

-- | Represent a permutation in a cycle notation.
--
-- >>> cycleForm [1,5,4,3,2,0]
-- [[1,5,0],[4,2],[3]]
cycleForm :: [Int] -> [[Int]]
cycleForm = ana coalgebra . IntMap.fromAscList . zip [0 ..]
  where
    coalgebra = maybe Nil makeCycle . IntMap.minViewWithKey
    makeCycle ((from, to), perm)
      | from == to = Cons [from] perm
      | otherwise = Cons (snoc ciclo from) (foldr IntMap.delete perm ciclo)
      where
        ciclo = takeWhile (/= from) (iterate (perm !) to)
