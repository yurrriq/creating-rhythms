module Data.Rhythm.Binary.BurrowsWheeler
  ( necklaces,
  )
where

import Control.Monad (guard)
import Data.List (elemIndices, sortOn, unfoldr)
import Data.Map ((!))
import qualified Data.Map as M
import Data.Ord (Down (..))

-- | All binary necklaces of a given length.
--
-- >>> necklaces 4
-- [[1,1,1,1],[1,1,1,0],[1,1,0,0],[1,0,1,0],[1,0,0,0],[0,0,0,0]]
necklaces :: Int -> [[Int]]
necklaces n =
  sortOn Down $
    map (reverse . take n . cycle) $
      lyndonWords [0, 1] n

-- Modified from
-- https://rosettacode.org/wiki/De_Bruijn_sequences#Permutation-based

-- the set of Lyndon words generated by inverse Burrows-Wheeler transform
lyndonWords :: (Ord a) => [a] -> Int -> [[a]]
lyndonWords s n = map (ref !!) <$> cycleForm perm
  where
    ref = take (length s ^ n) (cycle s)
    perm = s >>= (`elemIndices` ref)

-- represents a permutation in a cycle notation
cycleForm :: [Int] -> [[Int]]
cycleForm = unfoldr getCycle . M.fromList . zip [0 ..]
  where
    getCycle p =
      do
        guard (not (M.null p))
        ((x, y), m) <- M.minViewWithKey p
        if x == y
          then pure ([x], m)
          else do
            let c = takeWhile (/= x) (iterate (m !) y)
            pure (c ++ [x], foldr M.delete m c)
